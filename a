Problem A: Marios War
Here is the field, where each cell can have one of three values:

"0" - an empty cell;

"1" - a cell with the brown mushroom;

"2" - a cell with Mario.

Every minute, Mario crushes any brown mushroom that is adjacent to his position (up, down, top, bottom) and new Mario appears instead of mushroom, Mario does not move to the empty cell.

How many minutes will it take for Mario to kill all brown mushrooms in each cell? The number of Marios can be more than one. If this is impossible, return -1.

image

Input format
The first line contains two integers, m - number of rows of a field, n - number of columns of a field 
. The following m lines contain n values (0, 1, or 2).

Output format
Print the minimum time (in minutes) that must elapse until no cell will contain a brown mushroom. If any mushroom is unreachable for every Mario in a field print -1.

Examples
Input
3 3
2 1 1
1 1 0
0 1 1
Output
4
Input
3 3
2 1 1
0 1 1
1 0 1
Output
-1
Input
1 3
0 2 0
Output
0
Notes
The picture illustrates the procedure of the first example.

In the second example, the mushroom at (3, 1) is unreachable, because Mario can move 4-directionally. So, the output is -1.

In the last example, there are no brown mushrooms, there is nothing to kill, so the answer is 0.



#include <iostream>
#include <vector>
#include <map>
#include <queue>

using namespace std;

void bfs(queue<pair<int, int>> q, int marios, int mushrooms, vector<vector<int>> a, int n, int m){
    vector<vector<int>> visited(n, vector<int> (m, 0));

    visited[q.front().first][q.front().second] = 1;
    int cnt = 0;
    while(!q.empty()){
        int tempMarios = 0;
        bool isChanged = false;

        while(marios != 0){
            int x = q.front().first;
            int y = q.front().second;

            q.pop();

            if(x - 1 >= 0 && a[x-1][y] == 1 && visited[x-1][y] == 0){
                isChanged = true;
                tempMarios++;
                mushrooms--;
                visited[x-1][y] = 1;
                q.push(make_pair(x-1, y));
            }
            if(x + 1 < a.size() && a[x+1][y] == 1 && visited[x+1][y] == 0){
                isChanged = true;
                tempMarios++;
                mushrooms--;
                visited[x+1][y] = 1;
                q.push(make_pair(x+1, y));
            }
            if(y - 1 >= 0 && a[x][y-1] == 1 && visited[x][y-1] == 0){
                isChanged = true;
                tempMarios++;
                mushrooms--;
                visited[x][y-1] = 1;
                q.push(make_pair(x, y-1));
            }
            if(y + 1 < m && a[x][y+1] == 1 && visited[x][y+1] == 0){
                isChanged = true;
                tempMarios++;
                mushrooms--;
                visited[x][y+1] = 1;
                q.push(make_pair(x, y+1));
            }
            marios--;

        }
        if(isChanged == true){
            cnt++;
        }
        marios = tempMarios;
    }
    if(mushrooms == 0) cout << cnt;
    else cout << -1;
}


int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> a; 
    map<pair<int, int>, int> visited;
    queue<pair<int, int>> q;
    
    int mushrooms = 0, marios = 0;

    for (int i = 0; i < n; i++) {
        vector<int> tempRow;
        for (int j = 0; j < m; j++) {
            int temp;
            cin >> temp;
            tempRow.push_back(temp);
            if(temp == 1){
                mushrooms++;
            }
            if(temp == 2){
                marios++;
                q.push(make_pair(i, j));
            }
        }
        a.push_back(tempRow);
    }

    if(mushrooms == 0){
        cout << 0;
        return 0;
    } 

    bfs(q, marios, mushrooms, a, n, m);

    return 0;
}
